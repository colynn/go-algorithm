# 冒泡排序

## 概述
冒泡排序 是排序算法里面比较简单的一个排序，它重复地走访要排序的数列，一次比较两个元素，如果顺序不对则进行交换，并一直重复这样的走访操作，直到没有要交换的数据元素为止。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

## 原理/算法步骤

首先我们有一个存放着待排序的元素的数组如下；
```go
arr := []int{3, 5, 10, 8, 12, 1}
```

假设我们期望的是从小到大排序，

1. 从头部开始 比较相邻的元素。如果第一个比第二个大，就交换他们两个，对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

![image](https://user-images.githubusercontent.com/5203608/97689016-f1156700-1ad5-11eb-90bf-120cc9977cbd.png)

2. 经过第一步我们已经找到了最大的数12， 接下来的第2次排序就只对剩下的4个元素排序。如下图所示：

![image](https://user-images.githubusercontent.com/5203608/97689660-e3acac80-1ad6-11eb-807e-2350b02401c4.png)


3. 持续对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

这个算法有些类似于我们在操场排队跑步，老师总是说："高的站前面，低的站后面"。我们一开始并不一定会站到准确的位置上， 接着老师又说："你比前面的高，和前面的换换，还高，再和前面换换"， 就这样找到自己的位置。

## 动图演示

![bubbleSort](https://user-images.githubusercontent.com/5203608/97680363-8a8e4a00-1ad1-11eb-81ba-936e536b803e.gif)

_注_: 
1. 黄色为元素为排好的元素，绿色为待排序的元素
2. 图转自 https://sort.hust.cc/1.bubblesort




## 特点及性能

通过冒泡排序的算法思想，我们发现冒泡排序算法在每轮排序中会使一个元素排到一端，也就是最终需要 n-1 轮这样的排序（n 为待排序的数列的长度), 冒泡排序的平均时间复杂度是 O(n2)。

冒泡排序是 __稳定的__ ，因为在比较过程中，只有后一个元素比前面的元素大时才会对它们交换位置并向上冒出，对于同样大小的元素，是不需要交换位置的，所以对于同样大小的元素来说，相对位置是不会改变的。

冒泡排序算法的时间复杂度其实比较高。从 1956 年开始就有人研究冒泡排序算法，后续也有很多人对这个算法进行改进，但结果都很一般，正如 1974 年的图灵奖获得者所说的：“冒泡排序除了它迷人的名字和引起的某些有趣的理论问题，似乎没有什么值得推荐的。”


## 适用场景

对于冒泡排序，我们应该对它的思想进行理解，作为排序算法学习的引导，让我们的思维更加开阔。

虽然冒泡排序在我们的实际工作中并不会用到，其他排序算法多多少少比冒泡排序算法的性能更高，但是我们还是要掌握冒泡排序的思想及实现，并且在面试时还是有可能会用到。